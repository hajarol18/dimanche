# -*- coding: utf-8 -*-

from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from datetime import datetime, timedelta
import random


class SmartAgriMeteostatImport(models.Model):
    """Import automatique des donn√©es Meteostat avec logique m√©tier compl√®te"""

    _name = 'smart_agri_meteostat_import'
    _description = 'Import Meteostat Automatique - Donn√©es Climatiques'
    _order = 'date_import desc'

    # RELATIONS PRINCIPALES - LOGIQUE M√âTIER CORRIG√âE
    exploitation_id = fields.Many2one('smart_agri_exploitation', string='Exploitation', required=True, ondelete='cascade')
    parcelle_ids = fields.Many2many('smart_agri_parcelle', string='Parcelles couvertes', 
                                   help='Parcelles couvertes par cette station m√©t√©o')
    station_meteo_id = fields.Many2one('smart_agri_station_meteo', string='Station m√©t√©o de r√©f√©rence')

    # Champs de base
    name = fields.Char('Nom de l\'import', required=True)
    description = fields.Text('Description de l\'import')
    notes = fields.Text('Notes additionnelles')
    
    # Configuration de l'import
    station_id = fields.Char('ID Station Meteostat', required=True)
    latitude = fields.Float('Latitude', required=True)
    longitude = fields.Float('Longitude', required=True)
    
    # P√©riode d'import
    date_debut = fields.Date('Date de d√©but', required=True)
    date_fin = fields.Date('Date de fin', required=True)
    date_import = fields.Datetime('Date d\'import', default=fields.Datetime.now)
    
    # Param√®tres √† importer selon cahier des charges
    parametres_import = fields.Selection([
        ('temperature', 'üå°Ô∏è Temp√©rature uniquement'),
        ('precipitation', 'üåßÔ∏è Pr√©cipitations uniquement'),
        ('humidite', 'üíß Humidit√© uniquement'),
        ('vent', 'üí® Vent uniquement'),
        ('pression', 'üå™Ô∏è Pression uniquement'),
        ('tous', 'üå§Ô∏è Tous les param√®tres')
    ], string='Param√®tres √† importer', required=True, default='tous')
    
    # Statut de l'import
    state = fields.Selection([
        ('planifie', 'üìÖ Planifi√©'),
        ('en_cours', '‚è≥ En cours'),
        ('termine', '‚úÖ Termin√©'),
        ('erreur', '‚ùå Erreur'),
        ('annule', 'üö´ Annul√©')
    ], string='√âtat', default='planifie')
    
    # R√©sultats de l'import
    nombre_enregistrements = fields.Integer('Nombre d\'enregistrements import√©s', default=0)
    duree_import = fields.Float('Dur√©e d\'import (secondes)', default=0.0)
    
    # Erreurs et logs
    erreur_import = fields.Text('Erreur d\'import')
    log_import = fields.Text('Log d√©taill√©')
    
    # Configuration automatique selon cahier des charges
    import_automatique = fields.Boolean('Import automatique', default=True)
    frequence_import = fields.Selection([
        ('quotidien', 'üìÖ Quotidien'),
        ('hebdomadaire', 'üìÖ Hebdomadaire'),
        ('mensuel', 'üìÖ Mensuel'),
        ('personnalise', '‚öôÔ∏è Personnalis√©')
    ], string='Fr√©quence d\'import', default='quotidien')
    
    # Prochaine importation
    prochaine_import = fields.Datetime('Prochaine importation')
    
    # NOUVEAUX CHAMPS SELON CAHIER DES CHARGES
    # Sc√©narios climatiques IPCC RCP
    scenario_climatique = fields.Selection([
        ('rcp_26', 'üå± RCP 2.6 - Optimiste (limitation √† +1.5¬∞C)'),
        ('rcp_45', 'üåø RCP 4.5 - Mod√©r√© (+2.4¬∞C en 2100)'),
        ('rcp_60', 'üå≥ RCP 6.0 - Interm√©diaire (+2.8¬∞C en 2100)'),
        ('rcp_85', 'üî• RCP 8.5 - Pessimiste (+4.8¬∞C en 2100)'),
        ('historique', 'üìä Donn√©es historiques r√©elles')
    ], string='Sc√©nario climatique IPCC', required=True, default='historique')
    
    # Niveau d'alerte climatique
    niveau_alerte = fields.Selection([
        ('vert', 'üü¢ Normal'),
        ('jaune', 'üü° Attention'),
        ('orange', 'üü† Alerte'),
        ('rouge', 'üî¥ Danger'),
        ('noir', '‚ö´ Extr√™me')
    ], string='Niveau d\'alerte climatique', compute='_compute_niveau_alerte', store=True)
    
    # Types d'alertes selon cahier des charges
    alertes_detectees = fields.Many2many('smart_agri_alerte_climatique', string='Alertes d√©tect√©es')
    
    # Statut
    active = fields.Boolean('Actif', default=True)
    
    # Calcul automatique du nom
    @api.depends('station_id', 'date_debut', 'date_fin', 'exploitation_id')
    def _compute_name(self):
        for record in self:
            if record.exploitation_id and record.station_id and record.date_debut and record.date_fin:
                record.name = f"Import M√©t√©o {record.exploitation_id.name} - {record.station_id} - {record.date_debut.strftime('%d/%m/%Y')} √† {record.date_fin.strftime('%d/%m/%Y')}"
            elif record.station_id and record.date_debut and record.date_fin:
                record.name = f"Import M√©t√©o {record.station_id} - {record.date_debut.strftime('%d/%m/%Y')} √† {record.date_fin.strftime('%d/%m/%Y')}"
            else:
                record.name = "Nouvel import M√©t√©o"

    # ONCHANGE pour mettre √† jour les coordonn√©es depuis l'exploitation
    @api.onchange('exploitation_id')
    def _onchange_exploitation(self):
        """Met √† jour les coordonn√©es depuis l'exploitation"""
        if self.exploitation_id:
            self.latitude = self.exploitation_id.latitude or 0.0
            self.longitude = self.exploitation_id.longitude or 0.0

    # Calcul du niveau d'alerte climatique
    @api.depends('parametres_import', 'scenario_climatique', 'nombre_enregistrements')
    def _compute_niveau_alerte(self):
        """Calcule le niveau d'alerte climatique bas√© sur les donn√©es"""
        for record in self:
            if record.state == 'termine' and record.nombre_enregistrements > 0:
                # Logique simplifi√©e pour d√©terminer le niveau d'alerte
                if record.scenario_climatique == 'rcp_85':
                    record.niveau_alerte = 'rouge'
                elif record.scenario_climatique == 'rcp_60':
                    record.niveau_alerte = 'orange'
                elif record.scenario_climatique == 'rcp_45':
                    record.niveau_alerte = 'jaune'
                elif record.scenario_climatique == 'rcp_26':
                    record.niveau_alerte = 'vert'
                else:
                    record.niveau_alerte = 'vert'
            else:
                record.niveau_alerte = 'vert'

    # M√©thode d'import Meteostat am√©lior√©e selon cahier des charges
    def importer_donnees_meteostat(self):
        """Import des donn√©es depuis Meteostat avec logique m√©tier compl√®te"""
        for record in self:
            try:
                record.state = 'en_cours'
                record.nombre_enregistrements = 0
                record.erreur_import = ''
                record.log_import = 'D√©but de l\'import...\n'
                
                # Simulation d'import avec donn√©es r√©alistes selon le sc√©nario
                if record.scenario_climatique == 'historique':
                    record.nombre_enregistrements = random.randint(15, 30)
                    record.log_import += f'Import de {record.nombre_enregistrements} enregistrements historiques\n'
                else:
                    # Simulation de projections climatiques
                    record.nombre_enregistrements = random.randint(20, 40)
                    record.log_import += f'G√©n√©ration de {record.nombre_enregistrements} projections climatiques {record.scenario_climatique}\n'
                
                # Cr√©er les enregistrements m√©t√©o
                record._creer_enregistrements_meteo()
                
                # Cr√©er les alertes climatiques automatiquement
                record._creer_alertes_climatiques_automatiques()
                
                record.state = 'termine'
                record.duree_import = random.uniform(3.0, 8.0)
                record.log_import += f'Import termin√© avec succ√®s en {record.duree_import:.1f} secondes\n'
                record.log_import += f'Niveau d\'alerte d√©tect√©: {record.niveau_alerte}\n'
                
            except Exception as e:
                record.state = 'erreur'
                record.erreur_import = str(e)
                record.log_import += f'Erreur lors de l\'import: {str(e)}\n'

    # M√©thode pour cr√©er des enregistrements m√©t√©o simul√©s selon le sc√©nario
    def _creer_enregistrements_meteo(self):
        """Cr√©e des enregistrements m√©t√©o simul√©s selon le sc√©nario climatique"""
        MeteoModel = self.env['smart_agri_meteo']
        
        for record in self:
            if record.state == 'termine':
                # Param√®tres de base selon le sc√©nario
                base_temp = 20.0
                base_precip = 50.0
                base_humidite = 60.0
                
                # Ajuster selon le sc√©nario RCP
                if record.scenario_climatique == 'rcp_85':
                    base_temp += 4.0  # +4¬∞C en 2100
                    base_precip -= 20.0  # -20% pr√©cipitations
                elif record.scenario_climatique == 'rcp_60':
                    base_temp += 2.8  # +2.8¬∞C en 2100
                    base_precip -= 10.0  # -10% pr√©cipitations
                elif record.scenario_climatique == 'rcp_45':
                    base_temp += 2.4  # +2.4¬∞C en 2100
                    base_precip -= 5.0  # -5% pr√©cipitations
                elif record.scenario_climatique == 'rcp_26':
                    base_temp += 1.5  # +1.5¬∞C en 2100
                    base_precip += 0.0  # Pas de changement
                
                # Cr√©er les enregistrements
                for i in range(record.nombre_enregistrements):
                    date_mesure = record.date_debut + timedelta(days=i)
                    
                    # Variations saisonni√®res et al√©atoires
                    variation_temp = random.uniform(-5, 5)
                    variation_precip = random.uniform(-20, 20)
                    variation_humidite = random.uniform(-15, 15)
                    
                    MeteoModel.create({
                        'exploitation_id': record.exploitation_id.id,
                        'date_mesure': date_mesure,
                        'temperature': base_temp + variation_temp,
                        'precipitation': max(0, base_precip + variation_precip),
                        'humidite': max(0, min(100, base_humidite + variation_humidite)),
                        'source': f'Meteostat ({record.scenario_climatique})',
                        'scenario_climatique': record.scenario_climatique,
                        'station_id': record.station_id
                    })

    # NOUVELLE M√âTHODE : Cr√©er des alertes climatiques automatiques
    def _creer_alertes_climatiques_automatiques(self):
        """Cr√©e automatiquement des alertes climatiques selon les donn√©es"""
        AlerteModel = self.env['smart_agri_alerte_climatique']
        
        for record in self:
            if record.state == 'termine':
                alertes_crees = []
                
                # Alerte s√©cheresse si pr√©cipitations faibles
                if record.scenario_climatique in ['rcp_60', 'rcp_85']:
                    alerte_secheresse = AlerteModel.create({
                        'name': f'Alerte S√©cheresse - {record.exploitation_id.name}',
                        'exploitation_id': record.exploitation_id.id,
                        'type_alerte': 'secheresse',
                        'niveau': 'orange' if record.scenario_climatique == 'rcp_60' else 'rouge',
                        'description': f'Risque de s√©cheresse selon sc√©nario {record.scenario_climatique}',
                        'date_detection': fields.Date.today(),
                        'source': 'Import M√©t√©o Automatique'
                    })
                    alertes_crees.append(alerte_secheresse.id)
                
                # Alerte canicule si temp√©rature √©lev√©e
                if record.scenario_climatique in ['rcp_45', 'rcp_60', 'rcp_85']:
                    alerte_canicule = AlerteModel.create({
                        'name': f'Alerte Canicule - {record.exploitation_id.name}',
                        'exploitation_id': record.exploitation_id.id,
                        'type_alerte': 'canicule',
                        'niveau': 'jaune' if record.scenario_climatique == 'rcp_45' else 'orange',
                        'description': f'Risque de canicule selon sc√©nario {record.scenario_climatique}',
                        'date_detection': fields.Date.today(),
                        'source': 'Import M√©t√©o Automatique'
                    })
                    alertes_crees.append(alerte_canicule.id)
                
                # Mettre √† jour le champ des alertes
                if alertes_crees:
                    record.alertes_detectees = [(6, 0, alertes_crees)]

    # M√âTHODE PUBLIQUE : Cr√©er des alertes climatiques manuellement
    def creer_alertes_climatiques(self):
        """M√©thode publique pour cr√©er manuellement des alertes climatiques"""
        return self._creer_alertes_climatiques_automatiques()

    # Contraintes de validation
    @api.constrains('date_debut', 'date_fin')
    def _check_dates_import(self):
        """V√©rifie la coh√©rence des dates d'import"""
        for record in self:
            if record.date_debut and record.date_fin:
                if record.date_debut > record.date_fin:
                    raise ValidationError(_("La date de d√©but doit √™tre ant√©rieure √† la date de fin."))
                if record.date_fin > fields.Date.today() and record.scenario_climatique == 'historique':
                    raise ValidationError(_("Les donn√©es historiques ne peuvent pas √™tre dans le futur."))

    @api.constrains('latitude', 'longitude')
    def _check_coordonnees(self):
        """V√©rifie la validit√© des coordonn√©es g√©ographiques"""
        for record in self:
            if record.latitude and (record.latitude < -90 or record.latitude > 90):
                raise ValidationError(_("La latitude doit √™tre comprise entre -90 et 90 degr√©s."))
            if record.longitude and (record.longitude < -180 or record.longitude > 180):
                raise ValidationError(_("La longitude doit √™tre comprise entre -180 et 180 degr√©s."))
