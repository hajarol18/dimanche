# -*- coding: utf-8 -*-

from odoo import models, fields, api
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class SmartAgriExploitation(models.Model):
    """Exploitation agricole - Modèle central"""

    _name = 'smart_agri_exploitation'
    _description = 'Exploitation Agricole'
    _order = 'name'

    # Champs de base
    name = fields.Char('Nom de l\'exploitation', required=True)
    code = fields.Char('Code exploitation', required=True, size=20)
    description = fields.Text('Description')
    
    # Localisation
    adresse = fields.Text('Adresse complète')
    commune = fields.Char('Commune')
    departement = fields.Char('Département')
    region = fields.Char('Région')
    code_postal = fields.Char('Code postal')
    
    # Caractéristiques
    surface_totale = fields.Float('Surface totale (ha)', required=True, default=0.0)
    
    # COORDONNÉES GPS POUR IMPORT MÉTÉO AUTOMATIQUE
    latitude = fields.Float('Latitude', digits=(16, 8), help='Latitude pour import météo automatique')
    longitude = fields.Float('Longitude', digits=(16, 8), help='Longitude pour import météo automatique')
    altitude = fields.Float('Altitude (m)', help='Altitude de l\'exploitation')
    
    # CARACTÉRISTIQUES ENVIRONNEMENTALES
    zone_climatique = fields.Selection([
        ('mediterraneen', 'Méditerranéen'),
        ('continental', 'Continental'),
        ('oceanique', 'Océanique'),
        ('montagnard', 'Montagnard'),
        ('tropical', 'Tropical'),
        ('aride', 'Aride')
    ], string='Zone climatique', default='mediterraneen')
    
    type_sol = fields.Selection([
        ('argileux', 'Argileux'),
        ('limoneux', 'Limoneux'),
        ('sableux', 'Sableux'),
        ('calcaire', 'Calcaire'),
        ('humifere', 'Humifère'),
        ('tourbeux', 'Tourbeux')
    ], string='Type de sol', default='argileux')
    
    ph_sol = fields.Float('pH du sol', help='pH du sol (0-14)')
    capacite_retention = fields.Float('Capacité de rétention (mm)', help='Capacité de rétention d\'eau du sol')
    type_exploitation = fields.Selection([
        ('cereales', 'Céréales'),
        ('viticulture', 'Viticulture'),
        ('arboriculture', 'Arboriculture'),
        ('maraichage', 'Maraîchage'),
        ('elevage', 'Élevage'),
        ('mixte', 'Mixte'),
        ('autre', 'Autre')
    ], string='Type d\'exploitation', required=True)
    
    # Propriétaire/Exploitant
    proprietaire = fields.Char('Propriétaire')
    exploitant = fields.Char('Exploitant')
    telephone = fields.Char('Téléphone')
    email = fields.Char('Email')
    
    # Date de création
    date_creation = fields.Date('Date de création', default=fields.Date.today, readonly=True)
    
    # Statut
    state = fields.Selection([
        ('en_creation', 'En création'),
        ('active', 'Active'),
        ('inactive', 'Inactive')
    ], string='État', default='en_creation')
    
    # Statut
    active = fields.Boolean('Actif', default=True)
    notes = fields.Text('Notes et observations')

    # RELATIONS SIMPLIFIÉES (éviter les conflits circulaires)
    parcelle_ids = fields.One2many('smart_agri_parcelle', 'exploitation_id', string='Parcelles')
    culture_ids = fields.One2many('smart_agri_culture', 'exploitation_id', string='Cultures')
    intervention_ids = fields.One2many('smart_agri_intervention', 'exploitation_id', string='Interventions')
    meteo_ids = fields.One2many('smart_agri_meteo', 'exploitation_id', string='Données météo')
    meteostat_import_ids = fields.One2many('smart_agri_meteostat_import', 'exploitation_id', string='Imports Meteostat')
    alerte_climatique_ids = fields.One2many('smart_agri_alerte_climatique', 'exploitation_id', string='Alertes climatiques')
    tendance_climatique_ids = fields.One2many('smart_agri_tendance_climatique', 'exploitation_id', string='Tendances climatiques')
    ia_prediction_ids = fields.One2many('smart_agri_ia_predictions', 'exploitation_id', string='Prédictions IA')
    intrant_ids = fields.One2many('smart_agri_intrants', 'exploitation_id', string='Intrants')
    utilisation_intrant_ids = fields.One2many('smart_agri_utilisation_intrant', 'exploitation_id', string='Utilisations d\'intrants')

    # CHAMPS CALCULÉS
    nombre_parcelles = fields.Integer('Nombre de parcelles', compute='_compute_nombre_parcelles', store=True)
    nombre_cultures_actives = fields.Integer('Cultures actives', compute='_compute_nombre_cultures_actives', store=True)
    surface_utilisee = fields.Float('Surface utilisée (ha)', compute='_compute_surface_utilisee', store=True)
    
    @api.depends('parcelle_ids')
    def _compute_nombre_parcelles(self):
        """Calcule le nombre de parcelles"""
        for record in self:
            record.nombre_parcelles = len(record.parcelle_ids)
    
    @api.depends('culture_ids.state')
    def _compute_nombre_cultures_actives(self):
        """Calcule le nombre de cultures actives"""
        for record in self:
            record.nombre_cultures_actives = len(record.culture_ids.filtered(lambda c: c.state == 'active'))
    
    @api.depends('culture_ids.surface_utilisee')
    def _compute_surface_utilisee(self):
        """Calcule la surface utilisée par les cultures"""
        for record in self:
            record.surface_utilisee = sum(record.culture_ids.mapped('surface_utilisee'))

    # MÉTHODES MÉTIER
    def action_voir_parcelles(self):
        """Action pour voir les parcelles de cette exploitation"""
        return {
            'name': f'Parcelles de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_parcelle',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_cultures(self):
        """Action pour voir les cultures de cette exploitation"""
        return {
            'name': f'Cultures de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_culture',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_interventions(self):
        """Action pour voir les interventions de cette exploitation"""
        return {
            'name': f'Interventions de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_intervention',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_meteo(self):
        """Action pour voir les données météo de cette exploitation"""
        return {
            'name': f'Météo de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_meteo',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_intrants(self):
        """Action pour voir les intrants de cette exploitation"""
        return {
            'name': f'Intrants de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_intrants',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_ia_predictions(self):
        """Action pour voir les prédictions IA de cette exploitation"""
        return {
            'name': f'Prédictions IA de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_ia_predictions',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }

    # MÉTHODE D'IMPORT MÉTÉO AUTOMATIQUE AVEC METEOSTAT
    def action_importer_meteo(self):
        """Import automatique des données météo depuis Meteostat selon la géolocalisation"""
        self.ensure_one()
        
        try:
            # 1. VÉRIFIER QUE L'EXPLOITATION A DES COORDONNÉES
            if not self.latitude or not self.longitude:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': 'Coordonnées manquantes',
                        'message': 'Veuillez d\'abord saisir la latitude et longitude de l\'exploitation pour l\'import automatique.',
                        'type': 'warning',
                        'sticky': False,
                    }
                }
            
            # 2. CRÉER UN IMPORT METEOSTAT AUTOMATIQUE
            import_meteostat = self.env['smart_agri_meteostat_import'].create({
                'exploitation_id': self.id,
                'station_id': f"GPS_{self.latitude}_{self.longitude}",
                'latitude': self.latitude,
                'longitude': self.longitude,
                'date_debut': fields.Date.today() - timedelta(days=7),
                'date_fin': fields.Date.today(),
                'parametres_import': 'tous',
                'import_automatique': True,
                'frequence_import': 'quotidien',
            })
            
            # 3. LANCER L'IMPORT AUTOMATIQUE
            donnees_importees = import_meteostat.importer_donnees_meteostat()
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Import météo automatique terminé',
                    'message': f'Import automatique depuis Meteostat pour {self.name} terminé avec succès. {len(donnees_importees)} jours de données importés.',
                    'type': 'success',
                    'sticky': False,
                }
            }
            
        except Exception as e:
            _logger.error(f"Erreur lors de l'import météo automatique: {str(e)}")
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Erreur d\'import automatique',
                    'message': f'Erreur lors de l\'import automatique: {str(e)}',
                    'type': 'danger',
                    'sticky': False,
                }
            }
    
    def _simuler_import_meteo(self):
        """Simuler l'import de données météo (en production, ceci viendrait d'une API)"""
        # Simulation de données météo pour les 7 derniers jours
        donnees = []
        date_debut = datetime.now() - timedelta(days=7)
        
        for i in range(7):
            date = date_debut + timedelta(days=i)
            donnees.append({
                'date': date.date(),
                'temperature_min': 12 + (i % 8),
                'temperature_max': 22 + (i % 12),
                'precipitation': 0 if i % 2 == 0 else 8 + (i % 15),
                'humidite': 55 + (i % 25),
                'vitesse_vent': 8 + (i % 18),
            })
        
        return donnees

    # MÉTHODE D'ANALYSE DES RISQUES CLIMATIQUES
    def action_analyse_risques_climatiques(self):
        """Analyse automatique des risques climatiques pour l'exploitation"""
        self.ensure_one()
        
        try:
            # 1. Récupérer les données météo récentes
            donnees_meteo = self._get_donnees_meteo_recentes()
            
            # 2. Analyser les tendances et détecter les risques
            risques_detectes = self._detecter_risques_climatiques(donnees_meteo)
            
            # 3. Créer ou mettre à jour les alertes
            alertes_creees = self._creer_alertes_climatiques(risques_detectes)
            
            # 4. Retourner un message de succès
            if alertes_creees:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': 'Analyse des risques terminée',
                        'message': f'Analyse basée sur {len(donnees_meteo)} jours de données. {len(alertes_creees)} alertes créées.',
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': 'Analyse des risques terminée',
                        'message': f'Analyse basée sur {len(donnees_meteo)} jours de données. Aucun risque détecté.',
                        'type': 'info',
                        'sticky': False,
                    }
                }
                
        except Exception as e:
            _logger.error(f"Erreur lors de l'analyse des risques: {str(e)}")
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Erreur d\'analyse',
                    'message': f'Erreur lors de l\'analyse: {str(e)}',
                    'type': 'danger',
                    'sticky': False,
                }
            }
    
    def _get_donnees_meteo_recentes(self):
        """Récupérer les données météo des 30 derniers jours"""
        # Simulation de données météo (en production, ceci viendrait d'une API)
        donnees = []
        date_debut = datetime.now() - timedelta(days=30)
        
        for i in range(30):
            date = date_debut + timedelta(days=i)
            donnees.append({
                'date': date.date(),
                'temperature_min': 15 + (i % 10),  # Simulation
                'temperature_max': 25 + (i % 15),  # Simulation
                'precipitation': 0 if i % 3 == 0 else 5 + (i % 20),  # Simulation
                'humidite': 60 + (i % 30),  # Simulation
                'vitesse_vent': 10 + (i % 20),  # Simulation
            })
        
        return donnees
    
    def _detecter_risques_climatiques(self, donnees_meteo):
        """Détecter les risques climatiques basés sur les données"""
        risques = []
        
        for jour in donnees_meteo:
            # Détection de sécheresse
            if jour['precipitation'] < 2 and jour['humidite'] < 40:
                risques.append({
                    'type': 'secheresse',
                    'niveau': 'modere' if jour['precipitation'] == 0 else 'faible',
                    'date': jour['date'],
                    'description': f'Sécheresse détectée le {jour["date"]}'
                })
            
            # Détection de canicule
            if jour['temperature_max'] > 35:
                risques.append({
                    'type': 'canicule',
                    'niveau': 'eleve' if jour['temperature_max'] > 40 else 'modere',
                    'date': jour['date'],
                    'description': f'Canicule détectée le {jour["date"]} (T° max: {jour["temperature_max"]}°C)'
                })
            
            # Détection de gel
            if jour['temperature_min'] < 0:
                risques.append({
                    'type': 'gel',
                    'niveau': 'eleve' if jour['temperature_min'] < -5 else 'modere',
                    'date': jour['date'],
                    'description': f'Gel détecté le {jour["date"]} (T° min: {jour["temperature_min"]}°C)'
                })
            
            # Détection de pluies intenses
            if jour['precipitation'] > 30:
                risques.append({
                    'type': 'pluies_intenses',
                    'niveau': 'eleve' if jour['precipitation'] > 50 else 'modere',
                    'date': jour['date'],
                    'description': f'Pluies intenses le {jour["date"]} ({jour["precipitation"]}mm)'
                })
        
        return risques
    
    def _creer_alertes_climatiques(self, risques):
        """Créer les alertes climatiques basées sur les risques détectés"""
        alertes_creees = []
        
        for risque in risques:
            # Vérifier si une alerte similaire existe déjà
            alerte_existante = self.env['smart_agri_alerte_climatique'].search([
                ('exploitation_id', '=', self.id),
                ('type_alerte', '=', risque['type']),
                ('date_debut', '=', risque['date']),
                ('state', 'in', ['active', 'en_cours'])
            ], limit=1)
            
            if not alerte_existante:
                # Créer une nouvelle alerte
                alerte = self.env['smart_agri_alerte_climatique'].create({
                    'name': f"Alerte {risque['type'].title()} - {risque['niveau'].title()}",
                    'type_alerte': risque['type'],
                    'niveau_gravite': risque['niveau'],
                    'description': risque['description'],
                    'date_debut': risque['date'],
                    'date_fin': risque['date'] + timedelta(days=1),
                    'exploitation_id': self.id,
                    'source_alerte': 'api_meteo',
                    'state': 'active',
                    'zone_geographique': f"Exploitation {self.name}",
                    'recommandations': self._get_recommandations_par_type(risque['type']),
                    'mesures_prevention': self._get_mesures_prevention(risque['type']),
                })
                
                alertes_creees.append(alerte)
        
        return alertes_creees
    
    def _get_recommandations_par_type(self, type_alerte):
        """Retourner les recommandations selon le type d'alerte"""
        recommandations = {
            'secheresse': 'Arroser les cultures sensibles, surveiller l\'état hydrique du sol, réduire les interventions stressantes',
            'canicule': 'Arroser tôt le matin ou tard le soir, ombrager les cultures sensibles, éviter les traitements phytosanitaires',
            'gel': 'Protéger les cultures sensibles avec des voiles, retarder les semis précoces, surveiller les dégâts',
            'pluies_intenses': 'Éviter les interventions sur sol détrempé, surveiller les risques de lessivage, protéger contre l\'érosion',
            'vent_fort': 'Renforcer les tuteurs, éviter les traitements par pulvérisation, surveiller les dégâts mécaniques',
            'grele': 'Protéger les cultures sensibles, évaluer les dégâts rapidement, planifier les resemis si nécessaire',
            'inondation': 'Éviter les interventions, drainer si possible, surveiller les risques de maladies',
        }
        
        return recommandations.get(type_alerte, 'Surveiller l\'évolution de la situation météorologique')
    
    def _get_mesures_prevention(self, type_alerte):
        """Retourner les mesures de prévention selon le type d'alerte"""
        mesures = {
            'secheresse': 'Installer un système d\'irrigation, pailler le sol, choisir des variétés résistantes à la sécheresse',
            'canicule': 'Installer des ombrières, optimiser l\'irrigation, choisir des variétés tolérantes à la chaleur',
            'gel': 'Installer des systèmes de chauffage, utiliser des variétés tardives, planifier les cultures en fonction des gelées',
            'pluies_intenses': 'Améliorer le drainage, installer des bandes enherbées, éviter la compaction du sol',
            'vent_fort': 'Installer des brise-vent, renforcer les structures, choisir des variétés résistantes au vent',
            'grele': 'Installer des filets anti-grêle, surveiller les prévisions, avoir un plan de secours',
            'inondation': 'Améliorer le drainage, éviter les zones basses, planifier l\'évacuation des eaux',
        }
        
        return mesures.get(type_alerte, 'Adapter les pratiques culturales aux conditions météorologiques')
