# -*- coding: utf-8 -*-

from odoo import models, fields, api
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class SmartAgriExploitation(models.Model):
    """Exploitation agricole - Mod√®le central"""

    _name = 'smart_agri_exploitation'
    _description = 'Exploitation Agricole'
    _order = 'name'

    # Champs de base
    name = fields.Char('Nom de l\'exploitation', required=True)
    code = fields.Char('Code exploitation', required=True, size=20)
    description = fields.Text('Description')
    
    # Localisation
    adresse = fields.Text('Adresse compl√®te')
    commune = fields.Char('Commune')
    departement = fields.Char('D√©partement')
    region = fields.Char('R√©gion')
    code_postal = fields.Char('Code postal')
    
    # Caract√©ristiques
    surface_totale = fields.Float('Surface totale (ha)', required=True, default=0.0)
    
    # COORDONN√âES GPS POUR IMPORT M√âT√âO AUTOMATIQUE
    latitude = fields.Float('Latitude', digits=(16, 8), help='Latitude pour import m√©t√©o automatique')
    longitude = fields.Float('Longitude', digits=(16, 8), help='Longitude pour import m√©t√©o automatique')
    altitude = fields.Float('Altitude (m)', help='Altitude de l\'exploitation')
    
    # CARACT√âRISTIQUES ENVIRONNEMENTALES
    zone_climatique = fields.Selection([
        ('mediterraneen', 'M√©diterran√©en'),
        ('continental', 'Continental'),
        ('oceanique', 'Oc√©anique'),
        ('montagnard', 'Montagnard'),
        ('tropical', 'Tropical'),
        ('aride', 'Aride')
    ], string='Zone climatique', default='mediterraneen')
    
    type_sol = fields.Selection([
        ('argileux', 'Argileux'),
        ('limoneux', 'Limoneux'),
        ('sableux', 'Sableux'),
        ('calcaire', 'Calcaire'),
        ('humifere', 'Humif√®re'),
        ('tourbeux', 'Tourbeux')
    ], string='Type de sol', default='argileux')
    
    ph_sol = fields.Float('pH du sol', help='pH du sol (0-14)')
    capacite_retention = fields.Float('Capacit√© de r√©tention (mm)', help='Capacit√© de r√©tention d\'eau du sol')
    type_exploitation = fields.Selection([
        ('cereales', 'C√©r√©ales'),
        ('viticulture', 'Viticulture'),
        ('arboriculture', 'Arboriculture'),
        ('maraichage', 'Mara√Æchage'),
        ('elevage', '√âlevage'),
        ('mixte', 'Mixte'),
        ('autre', 'Autre')
    ], string='Type d\'exploitation', required=True)
    
    # Propri√©taire/Exploitant
    proprietaire = fields.Char('Propri√©taire')
    exploitant = fields.Char('Exploitant')
    telephone = fields.Char('T√©l√©phone')
    email = fields.Char('Email')
    
    # Date de cr√©ation
    date_creation = fields.Date('Date de cr√©ation', default=fields.Date.today, readonly=True)
    
    # Statut
    state = fields.Selection([
        ('en_creation', 'En cr√©ation'),
        ('active', 'Active'),
        ('inactive', 'Inactive')
    ], string='√âtat', default='en_creation')
    
    # Statut
    active = fields.Boolean('Actif', default=True)
    notes = fields.Text('Notes et observations')

    # RELATIONS SIMPLIFI√âES (√©viter les conflits circulaires)
    parcelle_ids = fields.One2many('smart_agri_parcelle', 'exploitation_id', string='Parcelles')
    culture_ids = fields.One2many('smart_agri_culture', 'exploitation_id', string='Cultures')
    intervention_ids = fields.One2many('smart_agri_intervention', 'exploitation_id', string='Interventions')
    meteo_ids = fields.One2many('smart_agri_meteo', 'exploitation_id', string='Donn√©es m√©t√©o')
    meteostat_import_ids = fields.One2many('smart_agri_meteostat_import', 'exploitation_id', string='Imports Meteostat')
    alerte_climatique_ids = fields.One2many('smart_agri_alerte_climatique', 'exploitation_id', string='Alertes climatiques')
    tendance_climatique_ids = fields.One2many('smart_agri_tendance_climatique', 'exploitation_id', string='Tendances climatiques')
    ia_prediction_ids = fields.One2many('smart_agri_ia_predictions', 'exploitation_id', string='Pr√©dictions IA')
    intrant_ids = fields.One2many('smart_agri_intrants', 'exploitation_id', string='Intrants')
    utilisation_intrant_ids = fields.One2many('smart_agri_utilisation_intrant', 'exploitation_id', string='Utilisations d\'intrants')

    # CHAMPS CALCUL√âS POUR GESTION DES SURFACES
    surface_parcelles = fields.Float('Surface totale des parcelles (ha)', compute='_compute_surface_parcelles', store=True)
    surface_cultivee = fields.Float('Surface totale cultiv√©e (ha)', compute='_compute_surface_cultivee', store=True)
    surface_disponible = fields.Float('Surface disponible (ha)', compute='_compute_surface_disponible', store=True)
    taux_utilisation = fields.Float('Taux d\'utilisation (%)', compute='_compute_taux_utilisation', store=True)
    niveau_alerte_surface = fields.Selection([
        ('optimal', 'üü¢ Optimal'),
        ('attention', 'üü° Attention'),
        ('danger', 'üî¥ Danger')
    ], string='Niveau d\'alerte surface', compute='_compute_niveau_alerte_surface', store=True)
    nombre_parcelles = fields.Integer('Nombre de parcelles', compute='_compute_nombre_parcelles', store=True)
    nombre_cultures_actives = fields.Integer('Cultures actives', compute='_compute_nombre_cultures_actives', store=True)
    surface_utilisee = fields.Float('Surface utilis√©e (ha)', compute='_compute_surface_utilisee', store=True)
    
    @api.depends('parcelle_ids')
    def _compute_nombre_parcelles(self):
        """Calcule le nombre de parcelles"""
        for record in self:
            record.nombre_parcelles = len(record.parcelle_ids)
    
    @api.depends('culture_ids.state')
    def _compute_nombre_cultures_actives(self):
        """Calcule le nombre de cultures actives"""
        for record in self:
            record.nombre_cultures_actives = len(record.culture_ids.filtered(lambda c: c.state == 'active'))
    
    @api.depends('culture_ids.surface_utilisee')
    def _compute_surface_utilisee(self):
        """Calcule la surface utilis√©e par les cultures"""
        for record in self:
            record.surface_utilisee = sum(record.culture_ids.mapped('surface_utilisee'))

    # M√âTHODES M√âTIER
    def action_voir_parcelles(self):
        """Action pour voir les parcelles de cette exploitation"""
        return {
            'name': f'Parcelles de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_parcelle',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_cultures(self):
        """Action pour voir les cultures de cette exploitation"""
        return {
            'name': f'Cultures de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_culture',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_interventions(self):
        """Action pour voir les interventions de cette exploitation"""
        return {
            'name': f'Interventions de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_intervention',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_meteo(self):
        """Action pour voir les donn√©es m√©t√©o de cette exploitation"""
        return {
            'name': f'M√©t√©o de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_meteo',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_intrants(self):
        """Action pour voir les intrants de cette exploitation"""
        return {
            'name': f'Intrants de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_intrants',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }
    
    def action_voir_ia_predictions(self):
        """Action pour voir les pr√©dictions IA de cette exploitation"""
        return {
            'name': f'Pr√©dictions IA de {self.name}',
            'type': 'ir.actions.act_window',
            'res_model': 'smart_agri_ia_predictions',
            'view_mode': 'list,form',
            'domain': [('exploitation_id', '=', self.id)],
            'context': {'default_exploitation_id': self.id},
        }

    # M√âTHODE D'IMPORT M√âT√âO AUTOMATIQUE AVEC METEOSTAT
    def action_importer_meteo(self):
        """Import automatique des donn√©es m√©t√©o depuis Meteostat selon la g√©olocalisation"""
        self.ensure_one()
        
        try:
            # 1. V√âRIFIER QUE L'EXPLOITATION A DES COORDONN√âES
            if not self.latitude or not self.longitude:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': 'Coordonn√©es manquantes',
                        'message': 'Veuillez d\'abord saisir la latitude et longitude de l\'exploitation pour l\'import automatique.',
                        'type': 'warning',
                        'sticky': False,
                    }
                }
            
            # 2. CR√âER UN IMPORT METEOSTAT AUTOMATIQUE
            import_meteostat = self.env['smart_agri_meteostat_import'].create({
                'exploitation_id': self.id,
                'station_id': f"GPS_{self.latitude}_{self.longitude}",
                'latitude': self.latitude,
                'longitude': self.longitude,
                'date_debut': fields.Date.today() - timedelta(days=7),
                'date_fin': fields.Date.today(),
                'parametres_import': 'tous',
                'import_automatique': True,
                'frequence_import': 'quotidien',
            })
            
            # 3. LANCER L'IMPORT AUTOMATIQUE
            donnees_importees = import_meteostat.importer_donnees_meteostat()
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Import m√©t√©o automatique termin√©',
                    'message': f'Import automatique depuis Meteostat pour {self.name} termin√© avec succ√®s. {len(donnees_importees)} jours de donn√©es import√©s.',
                    'type': 'success',
                    'sticky': False,
                }
            }
            
        except Exception as e:
            _logger.error(f"Erreur lors de l'import m√©t√©o automatique: {str(e)}")
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Erreur d\'import automatique',
                    'message': f'Erreur lors de l\'import automatique: {str(e)}',
                    'type': 'danger',
                    'sticky': False,
                }
            }
    
    def _simuler_import_meteo(self):
        """Simuler l'import de donn√©es m√©t√©o (en production, ceci viendrait d'une API)"""
        # Simulation de donn√©es m√©t√©o pour les 7 derniers jours
        donnees = []
        date_debut = datetime.now() - timedelta(days=7)
        
        for i in range(7):
            date = date_debut + timedelta(days=i)
            donnees.append({
                'date': date.date(),
                'temperature_min': 12 + (i % 8),
                'temperature_max': 22 + (i % 12),
                'precipitation': 0 if i % 2 == 0 else 8 + (i % 15),
                'humidite': 55 + (i % 25),
                'vitesse_vent': 8 + (i % 18),
            })
        
        return donnees

    # M√âTHODE D'ANALYSE DES RISQUES CLIMATIQUES
    def action_analyse_risques_climatiques(self):
        """Analyse automatique des risques climatiques pour l'exploitation"""
        self.ensure_one()
        
        try:
            # 1. R√©cup√©rer les donn√©es m√©t√©o r√©centes
            donnees_meteo = self._get_donnees_meteo_recentes()
            
            # 2. Analyser les tendances et d√©tecter les risques
            risques_detectes = self._detecter_risques_climatiques(donnees_meteo)
            
            # 3. Cr√©er ou mettre √† jour les alertes
            alertes_creees = self._creer_alertes_climatiques(risques_detectes)
            
            # 4. Retourner un message de succ√®s
            if alertes_creees:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': 'Analyse des risques termin√©e',
                        'message': f'Analyse bas√©e sur {len(donnees_meteo)} jours de donn√©es. {len(alertes_creees)} alertes cr√©√©es.',
                        'type': 'success',
                        'sticky': False,
                    }
                }
            else:
                return {
                    'type': 'ir.actions.client',
                    'tag': 'display_notification',
                    'params': {
                        'title': 'Analyse des risques termin√©e',
                        'message': f'Analyse bas√©e sur {len(donnees_meteo)} jours de donn√©es. Aucun risque d√©tect√©.',
                        'type': 'info',
                        'sticky': False,
                    }
                }
                
        except Exception as e:
            _logger.error(f"Erreur lors de l'analyse des risques: {str(e)}")
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Erreur d\'analyse',
                    'message': f'Erreur lors de l\'analyse: {str(e)}',
                    'type': 'danger',
                    'sticky': False,
                }
            }
    
    def _get_donnees_meteo_recentes(self):
        """R√©cup√©rer les donn√©es m√©t√©o des 30 derniers jours"""
        # Simulation de donn√©es m√©t√©o (en production, ceci viendrait d'une API)
        donnees = []
        date_debut = datetime.now() - timedelta(days=30)
        
        for i in range(30):
            date = date_debut + timedelta(days=i)
            donnees.append({
                'date': date.date(),
                'temperature_min': 15 + (i % 10),  # Simulation
                'temperature_max': 25 + (i % 15),  # Simulation
                'precipitation': 0 if i % 3 == 0 else 5 + (i % 20),  # Simulation
                'humidite': 60 + (i % 30),  # Simulation
                'vitesse_vent': 10 + (i % 20),  # Simulation
            })
        
        return donnees
    
    def _detecter_risques_climatiques(self, donnees_meteo):
        """D√©tecter les risques climatiques bas√©s sur les donn√©es"""
        risques = []
        
        for jour in donnees_meteo:
            # D√©tection de s√©cheresse
            if jour['precipitation'] < 2 and jour['humidite'] < 40:
                risques.append({
                    'type': 'secheresse',
                    'niveau': 'modere' if jour['precipitation'] == 0 else 'faible',
                    'date': jour['date'],
                    'description': f'S√©cheresse d√©tect√©e le {jour["date"]}'
                })
            
            # D√©tection de canicule
            if jour['temperature_max'] > 35:
                risques.append({
                    'type': 'canicule',
                    'niveau': 'eleve' if jour['temperature_max'] > 40 else 'modere',
                    'date': jour['date'],
                    'description': f'Canicule d√©tect√©e le {jour["date"]} (T¬∞ max: {jour["temperature_max"]}¬∞C)'
                })
            
            # D√©tection de gel
            if jour['temperature_min'] < 0:
                risques.append({
                    'type': 'gel',
                    'niveau': 'eleve' if jour['temperature_min'] < -5 else 'modere',
                    'date': jour['date'],
                    'description': f'Gel d√©tect√© le {jour["date"]} (T¬∞ min: {jour["temperature_min"]}¬∞C)'
                })
            
            # D√©tection de pluies intenses
            if jour['precipitation'] > 30:
                risques.append({
                    'type': 'pluies_intenses',
                    'niveau': 'eleve' if jour['precipitation'] > 50 else 'modere',
                    'date': jour['date'],
                    'description': f'Pluies intenses le {jour["date"]} ({jour["precipitation"]}mm)'
                })
        
        return risques
    
    def _creer_alertes_climatiques(self, risques):
        """Cr√©er les alertes climatiques bas√©es sur les risques d√©tect√©s"""
        alertes_creees = []
        
        for risque in risques:
            # V√©rifier si une alerte similaire existe d√©j√†
            alerte_existante = self.env['smart_agri_alerte_climatique'].search([
                ('exploitation_id', '=', self.id),
                ('type_alerte', '=', risque['type']),
                ('date_debut', '=', risque['date']),
                ('state', 'in', ['active', 'en_cours'])
            ], limit=1)
            
            if not alerte_existante:
                # Cr√©er une nouvelle alerte
                alerte = self.env['smart_agri_alerte_climatique'].create({
                    'name': f"Alerte {risque['type'].title()} - {risque['niveau'].title()}",
                    'type_alerte': risque['type'],
                    'niveau_gravite': risque['niveau'],
                    'description': risque['description'],
                    'date_debut': risque['date'],
                    'date_fin': risque['date'] + timedelta(days=1),
                    'exploitation_id': self.id,
                    'source_alerte': 'api_meteo',
                    'state': 'active',
                    'zone_geographique': f"Exploitation {self.name}",
                    'recommandations': self._get_recommandations_par_type(risque['type']),
                    'mesures_prevention': self._get_mesures_prevention(risque['type']),
                })
                
                alertes_creees.append(alerte)
        
        return alertes_creees
    
    def _get_recommandations_par_type(self, type_alerte):
        """Retourner les recommandations selon le type d'alerte"""
        recommandations = {
            'secheresse': 'Arroser les cultures sensibles, surveiller l\'√©tat hydrique du sol, r√©duire les interventions stressantes',
            'canicule': 'Arroser t√¥t le matin ou tard le soir, ombrager les cultures sensibles, √©viter les traitements phytosanitaires',
            'gel': 'Prot√©ger les cultures sensibles avec des voiles, retarder les semis pr√©coces, surveiller les d√©g√¢ts',
            'pluies_intenses': '√âviter les interventions sur sol d√©tremp√©, surveiller les risques de lessivage, prot√©ger contre l\'√©rosion',
            'vent_fort': 'Renforcer les tuteurs, √©viter les traitements par pulv√©risation, surveiller les d√©g√¢ts m√©caniques',
            'grele': 'Prot√©ger les cultures sensibles, √©valuer les d√©g√¢ts rapidement, planifier les resemis si n√©cessaire',
            'inondation': '√âviter les interventions, drainer si possible, surveiller les risques de maladies',
        }
        
        return recommandations.get(type_alerte, 'Surveiller l\'√©volution de la situation m√©t√©orologique')
    
    def _get_mesures_prevention(self, type_alerte):
        """Retourner les mesures de pr√©vention selon le type d'alerte"""
        mesures = {
            'secheresse': 'Installer un syst√®me d\'irrigation, pailler le sol, choisir des vari√©t√©s r√©sistantes √† la s√©cheresse',
            'canicule': 'Installer des ombri√®res, optimiser l\'irrigation, choisir des vari√©t√©s tol√©rantes √† la chaleur',
            'gel': 'Installer des syst√®mes de chauffage, utiliser des vari√©t√©s tardives, planifier les cultures en fonction des gel√©es',
            'pluies_intenses': 'Am√©liorer le drainage, installer des bandes enherb√©es, √©viter la compaction du sol',
            'vent_fort': 'Installer des brise-vent, renforcer les structures, choisir des vari√©t√©s r√©sistantes au vent',
            'grele': 'Installer des filets anti-gr√™le, surveiller les pr√©visions, avoir un plan de secours',
            'inondation': 'Am√©liorer le drainage, √©viter les zones basses, planifier l\'√©vacuation des eaux',
        }
        
        return mesures.get(type_alerte, 'Adapter les pratiques culturales aux conditions m√©t√©orologiques')

    # ========================================
    # M√âTHODES DE CALCUL DES SURFACES
    # ========================================
    
    @api.depends('parcelle_ids.surface')
    def _compute_surface_parcelles(self):
        """Calcule la surface totale des parcelles"""
        for record in self:
            record.surface_parcelles = sum(record.parcelle_ids.mapped('surface'))
    
    @api.depends('culture_ids.surface_utilisee', 'culture_ids.state')
    def _compute_surface_cultivee(self):
        """Calcule la surface totale cultiv√©e (cultures actives)"""
        for record in self:
            cultures_actives = record.culture_ids.filtered(lambda c: c.state in ['active', 'planifiee'])
            record.surface_cultivee = sum(cultures_actives.mapped('surface_utilisee'))
    
    @api.depends('surface_totale', 'surface_parcelles')
    def _compute_surface_disponible(self):
        """Calcule la surface disponible"""
        for record in self:
            record.surface_disponible = record.surface_totale - record.surface_parcelles
    
    @api.depends('surface_totale', 'surface_cultivee')
    def _compute_taux_utilisation(self):
        """Calcule le taux d'utilisation de la surface"""
        for record in self:
            if record.surface_totale > 0:
                record.taux_utilisation = (record.surface_cultivee / record.surface_totale) * 100
            else:
                record.taux_utilisation = 0.0
    
    @api.depends('taux_utilisation')
    def _compute_niveau_alerte_surface(self):
        """D√©termine le niveau d'alerte selon le taux d'utilisation"""
        for record in self:
            if record.taux_utilisation <= 80:
                record.niveau_alerte_surface = 'optimal'
            elif record.taux_utilisation <= 95:
                record.niveau_alerte_surface = 'attention'
            else:
                record.niveau_alerte_surface = 'danger'

    # ========================================
    # CONTRAINTES M√âTIER
    # ========================================
    
    @api.constrains('surface_totale')
    def _check_surface_totale_positive(self):
        """V√©rifie que la surface totale est positive"""
        for record in self:
            if record.surface_totale <= 0:
                raise ValidationError("La surface totale de l'exploitation doit √™tre strictement positive.")
    
    @api.constrains('parcelle_ids')
    def _check_surface_parcelles_coherence(self):
        """V√©rifie la coh√©rence entre la surface totale et la somme des parcelles"""
        for record in self:
            if record.surface_parcelles > record.surface_totale:
                raise ValidationError(
                    f"La somme des surfaces des parcelles ({record.surface_parcelles:.2f} ha) "
                    f"ne peut pas d√©passer la surface totale de l'exploitation ({record.surface_totale:.2f} ha)."
                )
